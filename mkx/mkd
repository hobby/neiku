#!/bin/bash
# vim:ts=4:sw=4:expandtab

############################################################
# NAME
#     mkd - a toy for make and deploy targets.
#
# SYNOPSIS
#     mkd
#     mkd [ options ] [ targets ] ...
#
#     debug=on mkd ...
#
# OPTIONS
#       -C DIRECTORY  Change to DIRECTORY before doing anything.
#       -f FILE       Read FILE as a makefile.
#       -h            Print this message and exit.
#       -j [N]        Allow N jobs at once; infinite jobs with no arg.
#       -l [N]        Don't start multiple jobs unless load is below N.
#
#       -x            Don't use mkx makefile.
#       -z            Don't use make-flags config.
#
# AUTHORS
#     neiku project <ku7d@qq.com> 
#
# SEE ALSO
#     mkxrc_targets
#     mkxrc_modules
#     mkxrc_configs
#
# VERSION
#     2015/11/21: 支持命令行或者makefile中OUTPUT定义的target
#                 支持-f选项指定自定义makefile
#                 支持-C选项指定自定义make目录
#     2015/11/22: 支持绝对/相对目录递归mkd
#     2015/11/25: 支持部署路径跟着target配置走，独立于module
#                 支持可配置登录方式(目前只支持rsa)
#                 支持自定义make前/后执行命令(pre/post-make)
#                 支持deploy前/后执行命令(pre/post-deploy)
#     2015/11/26: 支持忽略未配置target
#     2015/11/28: 支持使用mkm查找target(project/global/system级别)
#                 支持使用mkm查找module(project/global/system级别)
#                 支持使用mkm查找config(project/global/system级别)
#     2015/12/03: 支持本地部署模块(local module)
#     2015/12/05: 支持基于密码登录的远程部署模块(passwd module)
#     2015/12/06: 支持非make编译的target(例如配置文件)
#     2015/12/11: 支持使用mk工具编译target
#     2015/12/23: 支持模式匹配target
#     2015/12/26: 支持忽略pre/post-deploy命令错误信息
#     2016/01/29: 支持透传make -j选项(并行编译)
#     2016/02/16: 支持自定义默认target变量名(key => output-name)
#                 (默认使用OUTPUT做为默认target变量名)
#     2016/02/17: 支持自定义选项(make选项集的子集 + mkx扩展)
#                 支持-x临时不使用mkx makefile(透传mk)
#                 支持-z临时不使用make-flags配置(透传mk)
#
############################################################

# target(*) <-----> module(1) <-----> deploy destination(1)

# help
function help()
{
    echo "Usage: mkd [ options ] [ targets ] ..."
    echo "Options:"
    echo "  -C DIRECTORY  Change to DIRECTORY before doing anything."
    echo "  -f FILE       Read FILE as a makefile."
    echo "  -j [N]        Allow N jobs at once; infinite jobs with no arg."
    echo "  -h            Print this message and exit."
    echo "  -l [N]        Don't start multiple jobs unless load is below N."
    echo ""
    echo "  -x            Don't use mkx makefile."
    echo "  -z            Don't use make-flags config."
    echo ""
    echo "Report bugs to <ku7d@qq.com>"
}

# mkd -C {cmdline_makedir} -f {cmdline_makefile} {cmdline_options} {cmdline_targets}
cmdline_makedir="`pwd`"
cmdline_makefile=""
cmdline_options=""
cmdline_options_x=""
cmdline_options_z=""
cmdline_targets=""

# parse cmdline
cmdline="$@"
mklog debug "origin-args:[$@]"
temp=$(getopt -o "C:f:hj::l::xz" --long "" -n "mkd" -- "$@")
if [ $? != 0 ] ; then
    echo "`help`" >&2
    exit 1
fi
eval set -- "$temp"
mklog debug "parsed-args:[$temp]"
while true
do
    case "$1" in
        -C) cmdline_makedir="$2" ;  shift 2 ;;
        -f) cmdline_makefile="$2" ; shift 2 ;;
        -h) echo "`help`" >&2; exit 0;;
        -j) cmdline_options="$cmdline_options -j$2"; shift 2;;
        -l) cmdline_options="$cmdline_options -l$2"; shift 2;;
        -x) cmdline_options_x="-x"; shift 1;;
        -z) cmdline_options_z="-z"; shift 1;;
        --) shift ; break ;;
        *)  echo "parse options error!" >&2 ; exit 1 ;;
    esac
done
cmdline_targets="$@"
mklog debug "cmdline_makedir:[$cmdline_makedir], cmdline_makefile:[$cmdline_makefile]," \
            "cmdline_options:[$cmdline_options], cmdline_targets:[$cmdline_targets]," \
            "cmdline_options_x:[$cmdline_options_x], cmdline_options_z:[$cmdline_options_z]"

# (using $makefile to make and) deploy $targets from $makedir
targets="$cmdline_targets"
makedir="$cmdline_makedir"
makefile="$cmdline_makefile"

# wrapper
succ_exit() { [ -n "$makedir" ] && echo "mkd: Leaving directory '$cmdline_makedir'"; exit 0; }
fail_exit() { [ -n "$makedir" ] && echo "mkd: Leaving directory '$cmdline_makedir'"; exit 1; }

# go into make directory if need
if [ -n "$makedir" ] ; then
    if [ ! -d "$makedir" ] ; then
        mklog error "check directory fail, directory:[$makedir]"
        exit 1
    fi

    echo "mkd: Entering directory '$makedir'"
    cd "$makedir" || fail_exit
fi

# get makefile from cmdline(by user) or make(auto load)
if [ -z "$makefile" ] ; then
    makefile="`make $cmdline_options $cmdline_targets -n -p 2>/dev/null \
               | grep '^MAKEFILE_LIST' \
               | head -n1 \
               | awk '{printf $3}'`"
    if [ -z "$makefile" -a -z "$targets" ] ; then
        mklog error "none-make targets not found, cmdline:[$cmdline]," \
                    "makefile:[$makefile], targets:[$targets]"
        fail_exit
    fi
fi
mklog debug "makefile:[$makefile], targets:[$targets]"

if [ -n "$makefile" ] ; then
    # check makefile
    if [ ! -f "$makefile" ] ; then
        mklog error "check makefile fail, makefile:[$makefile]"
        fail_exit
    fi

    # maybe mkd for sub directorys
    submakedirs="`make -f $makefile -n -p 2>/dev/null | grep '^DIRS =' | tail -n1 | cut -c8-`"
    mklog debug "submakedirs=$submakedirs"
    if [ -n "$submakedirs" ] ; then
        for subdir in $submakedirs
        do
            if [ "${subdir:0:1}" = "/" ] ; then
                mkd -C $subdir $cmdline_options
            else
                mkd -C $makedir/$subdir $cmdline_options
            fi
        done
        mklog debug "mkd for directorys end"
        succ_exit
    fi

    # get targets from cmdline
    if [ -z "$targets" ] ; then
        # default targets from $output var in makefile
        output="`mkm get config output-name OUTPUT`"
        length="$((${#output} + 4))"
        targets="`make -f $makefile -n -p 2>/dev/null | grep "^$output =" | cut -c$length-`"
        if [ -z "$targets" ] ; then
            mklog error "need-make targets not found, cmdline:[$cmdline]," \
                        "output-name:[$output], length:[$length]"
            fail_exit
        fi
    fi
    mklog debug "targets(need make):[$targets]"

    # make targets from cmdline(by user) or make(auto load)
    mk -f $makefile $cmdline_options $cmdline_options_x $cmdline_options_z $targets
    if [ $? -ne 0 ] ; then
        fail_exit
    fi
fi

# deploy targets
for target in $targets
do
    # .so target is specail
    if expr match "$target" ".*\.so$" >/dev/null 2>&1 ; then
        if ! expr match "$target" "^lib" >/dev/null 2>&1 ; then
            target="lib$target"
        fi
    fi
    # .a target is specail
    if expr match "$target" ".*\.a$" >/dev/null 2>&1 ; then
        if ! expr match "$target" "^lib" >/dev/null 2>&1 ; then
            target="lib$target"
        fi
    fi

    # find target's module
    module=""; hostpath="";
    eval `mkm find target $target \
          | awk '{printf "module=%s; hostpath=%s;" \
                         ,       $1,          $2}'`
    if [ -z "$module" ] ; then
        eval `mkm find targetreg $target \
             | awk '{printf "module=%s; hostpath=%s;" \
                            ,       $1,          $2}'`
        if [ -z "$module" ] ; then
            mklog error "module not found, target:[$target]"
            continue
        fi
        mklog debug "module found in targetreg, target:[$target]"
    fi 

    # find module's info
    mtype=""; username=""; rsapkey=""; hostname=""; hostport="";
    eval `mkm find module $module \
          | awk '{printf "mtype=%s; username=%s; rsapkey=%s; hostname=%s; hostport=%s;" \
                         ,     $2,          $3,         $4,          $5,          $6}'`
    mklog debug "target:[$target], module:[$module], mtype:[$mtype]," \
                "username:[$username], rsa-private:[$rsapkey]," \
                "hostname:[$hostname], hostport:[$hostport]," \
                "hostpath:[$hostpath], makedir:[$makedir]"
    if [ "$mtype" != "rsa" -a "$mtype" != "local" -a "$mtype" != "passwd" ] ; then
        mklog error "module type unsupported, type:[$mtype]," \
                    "supported type:[rsa, local, passwd], target:[$target]"
        continue
    fi

    # do deploy
    mkrun pre-deploy $target 2>/dev/null
    case "$mtype" in
        rsa)
            if [   -z "$username" -o -z "$rsapkey" \
                -o -z "$hostname" -o -z "$hostport" -o -z "$hostpath" ]
            then
                mklog error "rsa module not ok, target:[$target], module:[$module]"
                continue
            fi
            scp -C -i $rsapkey -P $hostport "$makedir/$target" $username@$hostname:$hostpath
            ;;
        local)
            cp -v "$makedir/$target" $hostpath
            ;;
        passwd)
            if [   -z "$username" -o -z "$rsapkey" \
                -o -z "$hostname" -o -z "$hostport" -o -z "$hostpath" ]
            then
                mklog error "passwd module not ok, target:[$target], module:[$module]"
                continue
            fi
            mkscpto "$makedir/$target" $username $rsapkey $hostname $hostport $hostpath
            ;;
        *)
            mklog error "module type unsupported, type:[$mtype]," \
                        "supported type:[rsa, local, passwd]"
            continue
            ;;
    esac
    mkrun post-deploy $target 2>/dev/null
done

# all done
succ_exit
